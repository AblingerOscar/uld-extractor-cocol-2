COMPILER Cocol2Extractor

LEX <<
  private static bool CommentHandler(char comCh, int comChCount, int level) {
    if (level > 1) return true; // only 1st level comments are considered
    if (comChCount == 1)
      CocolExtractor.Builder.NextCommentIsAction(comCh == '$');
    CocolExtractor.Builder.AddCommentChar(comCh);
    return true;
  }
>>

CHARACTER SETS
  letter   =  'A' .. 'Z' + 'a' .. 'z'.
  digit    =  '0' .. '9'.
  control  =  CHR(0) .. CHR(31) + CHR(127).
  noQuote1 =  ANY - "'" - control.
  noQuote2 =  ANY - '"' - control.
  ignore   =  EOL + CHR(9) IGNORE.

COMMENTS
  FROM '//' TO EOL            HANDLER CommentHandler.
  FROM '/*' TO '*/'           HANDLER CommentHandler.
  FROM '(*' TO '*)' NESTED.
  // sem/lex/local actions are treated as comments
  FROM '<<' TO '>>'.
  FROM '^^' TO EOL.

KEYWORDS
  'ALIAS'.       'ANY'.         'BY'.          'CASE'.        'CHARACTER'.
  'CHR'.         'CLASSES'.     'COMMENTS'.    'COMPILER'.    'END'.
  'EOL'.         'EPS'.         'FOLLOWED'.    'FROM'.        'HANDLER'.
  'IF'.          'IGNORE'.      'KEYWORDS'.    'LEX'.         'LEXLOCAL'.
  'LOCAL'.       'NESTED'.      'NONTERMINALS'.'PRAGMAS'.     'PRE'.
  'POST'.        'RULES'.       'SEM'.         'SYN'.         'SETS'.
  'TO'.          'TOKEN'.       'TOKENS'.

TOKENS
  '='. '+'. '-'. '|'. '.'. '('. ')'. '['. ']'. '{'. '}'. '..'.

TOKEN CLASSES
  ident<<out string identifier>>  ALIAS 'identifier' =
    letter { letter | digit } LEX<<identifier = tokenStr;>>.
  str<<out string str>> ALIAS 'string' =
    ( "'" { noQuote1 } "'" | '"' { noQuote2 } '"' ) LEX<<str = tokenStr.Substring(1, tokenStr.Length - 2);>>.
  num    ALIAS 'number' = digit { digit }.

NONTERMINALS
  Cocol2Extractor            ALIAS 'parser description'.

  SetDecl                    ALIAS 'set declaration'.
  ChrSet                     ALIAS 'character set'.
  Special                    ALIAS 'special set element'.

  CommentDecl                ALIAS 'comment declaration'.
  Delimiter                  ALIAS 'comment delimiter'.
  DelimiterPart              ALIAS 'comment delimiter part'.

  KeywordDecl                ALIAS 'keyword declaration'.

  TokenDecl                  ALIAS 'token declaration'.

  TokenClassDecl             ALIAS 'token class declaration'.

  PragmaDecl                 ALIAS 'pragma declaration'.

  NonterminalDecl            ALIAS 'nonterminal declaration'.

  AliasName                  ALIAS 'alias name'.

  LexExpr                    ALIAS 'lexical expression'.
  LexTerm                    ALIAS 'lexical term'.
  LexFact                    ALIAS 'lexical factor'.

  RuleDef                    ALIAS 'rule definition'.

  SynExpr                    ALIAS 'syntax expression'.
  SynTerm                    ALIAS 'syntax term'.
  SynFact                    ALIAS 'syntax factor'.

  LexDecl                    ALIAS 'lexical declaration'.
  LexAction                  ALIAS 'lexical action'.

  SemDecl                    ALIAS 'semantic declaration'.
  SynAction                  ALIAS 'syntax action'.
  SemAction                  ALIAS 'semantic action'.
  PreAction                  ALIAS 'pre action'.
  PostAction                 ALIAS 'post action'.

RULES
  Cocol2Extractor =
    'COMPILER' ident<<out _>> 
    [ 'LEX' ]
    [ 'SYN' ]
    [ 'SEM' ]
    [ 'IGNORE' 'CASE' ]
    [ 'CHARACTER' 'SETS' { SetDecl } ]
    [ 'COMMENTS' { CommentDecl } ]
    [ 'KEYWORDS' { KeywordDecl } ]
    [ 'TOKENS' { TokenDecl } ]
    [ 'TOKEN' 'CLASSES' { TokenClassDecl } ]
    [ 'PRAGMAS' { PragmaDecl } ]
    [ 'NONTERMINALS' { NonterminalDecl } ]
    [ 'RULES' SEM << CocolExtractor.Builder.StartOfRules(); >>
      { RuleDef } ]
    'END' ident<<out _>> '.'
  .

  SetDecl =
    ident<<out _>> '=' ChrSet { ( '+' | '-' ) ChrSet } [ 'IGNORE' ] '.'
  .

  ChrSet =
    ident<<out _>> | 'ANY' | 'EOL' | Special [ '..' Special ]
  .

  Special =
      str<<out _>> | 'CHR' '(' num ')'
  .

  CommentDecl =
    'FROM' Delimiter 'TO' Delimiter [ 'NESTED' ] [ 'HANDLER' ident<<out _>> ] '.'
  .

  Delimiter =
      DelimiterPart [ DelimiterPart ]
  .

  DelimiterPart =
      str<<out _>> | 'CHR' '(' num ')' | 'EOL'
  .

  KeywordDecl =
      ( ident<<out _>> [ AliasName ] [ '=' str<<out _>> { '|' str<<out _>> } ] | str<<out _>> [ AliasName ]) '.'
  .

  TokenDecl =
    ( ident<<out _>> [ AliasName ] [ '=' LexExpr ] | str<<out _>> [ AliasName ]) '.'
  .

  TokenClassDecl =
    ident<<out _>> [ AliasName ] [ '=' LexExpr [ LexDecl ] [ LexAction ] ] '.'
  .

  PragmaDecl =
    ident<<out _>> [ '=' LexExpr [ LexDecl ] [ LexAction ] ] [ SemDecl ] [ SemAction ] '.'
  .

  NonterminalDecl =
    ident<<out _>> [ AliasName ] '.'
    .

  AliasName =
    'ALIAS' ( ident<<out _>> | str<<out _>> )
  .

  LexExpr =
    LexTerm { '|' LexTerm }
  .

  LexTerm =
    LexFact { LexFact } [ 'IF' 'FOLLOWED' 'BY' '(' LexExpr ')' ]
  .

  LexFact =
    ident<<out _>> | str<<out _>> | 'CHR' '(' num ')' | 'EOL' | '(' LexExpr ')' | '[' LexExpr ']' | '{' LexExpr '}'
 .

  RuleDef = LOCAL<<string identifier = null; ISymbol[] symbols = null;>>
    ident<<out identifier>>
    '=' [ SemDecl ] [ PreAction ] [ PostAction ]
    SynExpr<<identifier, out symbols>>
      SEM <<if (symbols != null) CocolExtractor.Builder.AddRule(identifier, symbols); >>
    '.'
  .

  SynExpr<<string name, out ISymbol[] symbols>> =
    LOCAL<<IOneOf oneOf = null;
           ISymbol[] otherSymbols = null;
           symbols = null;
           uint cnt = 1;>>

    SynTerm<<name + "|" + 0, out symbols>>
    {
      '|' SynTerm<<name + "|" + cnt, out otherSymbols>>
            SEM<<
            if (oneOf == null)
            {
              if (symbols != null)
                AddRule(name + "|" + 0, symbols);
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            else
            {
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            if (oneOf != null)
              symbols = new ISymbol[] { oneOf };

            ++cnt;

            void AddRule(string ruleName, ISymbol[] ruleSymbols)
            {
              if (oneOf == null) // to avoid null-references -> default value
                oneOf = new OneOf(false, new string[0]);

              if (ruleSymbols.Length == 0)
                oneOf = new OneOf(true, oneOf.Options);
              else
              {
                CocolExtractor.Builder.AddRule(ruleName, ruleSymbols);

                var options = new List<string>(oneOf.Options.Length + 1);
                options.AddRange(oneOf.Options);
                options.Add(ruleName);
                oneOf = new OneOf(oneOf.AllowNone, options.ToArray());
              }
            }
            >>
    }
  .

  SynTerm<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; ISymbol[] additionalSymbols = null;uint cnt = 1;>>
     SynFact<<name + "_0", out symbols>>
     {
       SynFact<<name + "_" + cnt, out additionalSymbols>>
            SEM<<
            ++cnt;
            if (additionalSymbols != null)
            {
              if (symbols == null)
                symbols = additionalSymbols;
              else
              {
                var symbolList = new List<ISymbol>(symbols.Length + 1);
                symbolList.AddRange(symbols);
                symbolList.AddRange(additionalSymbols);
                symbols = symbolList.ToArray();
              }
            }
            >>
     }
 .

  SynFact<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; string str = null; ISymbol[] innerSymbols = null;>>
    // Reference to a NonTerminal (or token class)
    ( ident<<out str>> SEM<<symbols = new ISymbol[] { new NonTerminal(str) };>>
      EPS
    // String Terminal
     | str<<out str>> SEM<<symbols = new ISymbol[] { new StringTerminal(str) };>>
    // Syn or Sem actions should be ignored
     | ( SynAction | SemAction) SEM<<symbols = null;>>
    // Grouping -> simple inner rule and new NonTerminal
    //   theoretically could also check what's inside and either bubble up (if no | was used at top level)
    //   or wrap in an OneOf (if an | was used at top level)
     | '(' SynExpr<<name + "$inner", out innerSymbols>> ')'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else {
            CocolExtractor.Builder.AddRule(name + "$inner", innerSymbols);
            symbols = new ISymbol[] { new NonTerminal(name + "$inner") };
          }>>
    // Optional -> OneOf with AllowNone=true and only option being the symbols inside
     | '[' SynExpr<<name + "$optional", out innerSymbols>> ']'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else
          {
            CocolExtractor.Builder.AddRule(name + "$optional", innerSymbols);
            symbols = new ISymbol[] { new OneOf(true, new[] { name + "$optional" }) };
          }>>
    // zeroOrmore -> Transformed into new rule as following:
    //    A = { B } .
    // is transformed into
    //    A = OneOf(C)? .
    //    C = B OneOf(C)? .
     | '{' SynExpr<<name + "$zeroOrMore", out innerSymbols>> '}'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else
          {
            string zeroOrMoreName = name + "$zeroOrMore";

            var symbolList = new List<ISymbol>();
            symbolList.AddRange(innerSymbols);
            symbolList.Add(new NonTerminal(zeroOrMoreName));

            CocolExtractor.Builder.AddRule(zeroOrMoreName, symbolList.ToArray());
            symbols = new ISymbol[] { new OneOf(true, new[] { zeroOrMoreName }) };
          }
        >>
     | 'EPS' SEM<<symbols = new ISymbol[0];>>
     | 'ANY' // TODO: ?
   )
 .

  LexDecl =
    'LEXLOCAL'
  .

  LexAction =
    'LEX'
  .

  SemDecl =
    'LOCAL' EPS
  .

  SynAction =
    'SYN' EPS
  .

  SemAction =
    'SEM' EPS
  .

  PreAction =
    'PRE' EPS
  .
  
  PostAction =
    'POST' EPS
  .

END Cocol2Extractor.
