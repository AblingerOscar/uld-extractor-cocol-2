COMPILER Cocol2Extractor

LEX <<
  private static bool CommentHandler(char comCh, int comChCount, int level) {
    if (level > 1) return true; // only 1st level comments are considered

    if (comChCount > 1)
      CocolExtractor.Builder.AddCommentChar(comCh);
    else
    {
      var isAction = comCh == '$';
      CocolExtractor.Builder.NextCommentIsAction(isAction);
    }

    return true;
  }
>>

SEM <<
  private static readonly IDictionary<string, ISet<char> > definedCharacterSets = new Dictionary<string, ISet<char> >();
>>

CHARACTER SETS
  letter   =  'A' .. 'Z' + 'a' .. 'z'.
  digit    =  '0' .. '9'.
  control  =  CHR(0) .. CHR(31) + CHR(127).
  noQuote1 =  ANY - "'" - control.
  noQuote2 =  ANY - '"' - control.
  ignore   =  EOL + CHR(9) IGNORE.

COMMENTS
  FROM '//' TO EOL            HANDLER CommentHandler.
  FROM '/*' TO '*/'           HANDLER CommentHandler.
  FROM '(*' TO '*)' NESTED.
  // sem/lex/local actions are treated as comments
  FROM '<<' TO '>>'.
  FROM '^^' TO EOL.

KEYWORDS
  'ALIAS'.       'ANY'.         'BY'.          'CASE'.        'CHARACTER'.
  'CHR'.         'CLASSES'.     'COMMENTS'.    'COMPILER'.    'END'.
  'EOL'.         'EPS'.         'FOLLOWED'.    'FROM'.        'HANDLER'.
  'IF'.          'IGNORE'.      'KEYWORDS'.    'LEX'.         'LEXLOCAL'.
  'LOCAL'.       'NESTED'.      'NONTERMINALS'.'PRAGMAS'.     'PRE'.
  'POST'.        'RULES'.       'SEM'.         'SYN'.         'SETS'.
  'TO'.          'TOKEN'.       'TOKENS'.

TOKENS
  '='. '+'. '-'. '|'. '.'. '('. ')'. '['. ']'. '{'. '}'. '..'.

TOKEN CLASSES
  ident<<out string identifier>>  ALIAS 'identifier' =
    letter { letter | digit } LEX<<identifier = tokenStr;>>.
  str<<out string str>> ALIAS 'string' =
    ( "'" { noQuote1 } "'" | '"' { noQuote2 } '"' ) LEX<<str = tokenStr.Substring(1, tokenStr.Length - 2);>>.
  num<<out int num>>    ALIAS 'number' = digit { digit }  LEX<<num = Convert.ToInt32(tokenStr);>>.

NONTERMINALS
  Cocol2Extractor            ALIAS 'parser description'.

  SetDecl                    ALIAS 'set declaration'.
  ChrSet                     ALIAS 'character set'.
  Special                    ALIAS 'special set element'.

  CommentDecl                ALIAS 'comment declaration'.
  Delimiter                  ALIAS 'comment delimiter'.
  DelimiterPart              ALIAS 'comment delimiter part'.

  KeywordDecl                ALIAS 'keyword declaration'.

  TokenDecl                  ALIAS 'token declaration'.

  TokenClassDecl             ALIAS 'token class declaration'.

  PragmaDecl                 ALIAS 'pragma declaration'.

  NonterminalDecl            ALIAS 'nonterminal declaration'.

  AliasName                  ALIAS 'alias name'.

  LexExpr                    ALIAS 'lexical expression'.
  LexTerm                    ALIAS 'lexical term'.
  LexFact                    ALIAS 'lexical factor'.

  RuleDef                    ALIAS 'rule definition'.

  SynExpr                    ALIAS 'syntax expression'.
  SynTerm                    ALIAS 'syntax term'.
  SynFact                    ALIAS 'syntax factor'.

  LexExprNoRule              ALIAS 'lexical expression (without generating any rules)'.
  LexTermNoRule              ALIAS 'lexical term (without generating any rules)'.
  LexFactNoRule              ALIAS 'lexical factor (without generating any rules)'.

  LexDecl                    ALIAS 'lexical declaration'.
  LexAction                  ALIAS 'lexical action'.

  SemDecl                    ALIAS 'semantic declaration'.
  SynAction                  ALIAS 'syntax action'.
  SemAction                  ALIAS 'semantic action'.
  PreAction                  ALIAS 'pre action'.
  PostAction                 ALIAS 'post action'.

RULES
  Cocol2Extractor =
      LOCAL<<string identifier = "";>>
      SEM<<definedCharacterSets.Clear();>>
    'COMPILER' ident<<out identifier>> SEM<<CocolExtractor.Builder.AddStartRule(identifier); CocolExtractor.Builder.StartOfGrammar();>> 
    [ 'LEX' ]
    [ 'SYN' ]
    [ 'SEM' ]
    [ 'IGNORE' 'CASE' ]
    [ 'CHARACTER' 'SETS' { SetDecl } ]
    [ 'COMMENTS' { CommentDecl } ]
    [ 'KEYWORDS' { KeywordDecl } ]
    [ 'TOKENS' { TokenDecl } ]
    [ 'TOKEN' 'CLASSES' { TokenClassDecl } ]
    [ 'PRAGMAS' { PragmaDecl } ]
    [ 'NONTERMINALS' { NonterminalDecl } ]
    [ 'RULES' SEM << CocolExtractor.Builder.StartOfRules(); >>
      { RuleDef } ]
    'END' ident<<out _>> '.'
  .

  SetDecl =
      LOCAL<<
        string name = null;
        ISet<char> chSet = null;
        ISet<char> chSet2 = null;
        bool shouldAdd = true;>>
    ident<<out name>> '='
    ChrSet<<out chSet>>
      {
        ( '+' SEM<<shouldAdd = true;>> | '-' SEM<<shouldAdd = false;>> )
        ChrSet<<out chSet2>>
        SEM<<
          if (shouldAdd) {
            chSet.UnionWith(chSet2);
          } else {
            chSet.ExceptWith(chSet2);
          }
        >>
      }
    [ 'IGNORE' ] '.'
    SEM<<
      definedCharacterSets.Add(name, chSet);
      CocolExtractor.Builder.AddCharacterSetRule(name, chSet);
    >>
  .

  ChrSet<<out ISet<char> chSet>> =
      LOCAL<<
        chSet = null;
        string ident = null;
        ISet<char> special = null;>>

    ident<<out ident>> SEM<<chSet = definedCharacterSets[ident];>>
    | 'ANY' SEM<<chSet = CocolExtractor.ANY_CHARACTER_SET.ToHashSet();>>
    | 'EOL' SEM<<chSet = new HashSet<char>(1) { '\n' };>>
    | Special<<out chSet>>
      [
        '..'
        Special<<out special>> SEM<<chSet = new HashSet<char>(Enumerable.Range(chSet.First(), special.First() - chSet.First() + 1).Select(i => (char)i));>>
      ]
  .

  Special<<out ISet<char> set>> = LOCAL<<set = new HashSet<char>(); string str = null; int num = 0;>>
      str<<out str>> SEM<<set = str.ToHashSet();>>
      | 'CHR' '(' num<<out num>> SEM<<set.Add((char)num);>> ')'
  .

  CommentDecl =
    'FROM' Delimiter 'TO' Delimiter [ 'NESTED' ] [ 'HANDLER' ident<<out _>> ] '.'
  .

  Delimiter =
      DelimiterPart [ DelimiterPart ]
  .

  DelimiterPart =
      str<<out _>> | 'CHR' '(' num<<out _>> ')' | 'EOL'
  .

  KeywordDecl = LOCAL<<var str = ""; var ident = ""; var otherStr = ""; var options = new List<string>();>>
      (
          ident<<out ident>>
            [ AliasName ]
            [ '=' str<<out str>> SEM<<
                CocolExtractor.Builder.AddKeyword(str);
                options.Add(str);
              >>
              {
                '|' str<<out otherStr>>
                SEM<<
                  CocolExtractor.Builder.AddKeyword(str);
                  options.Add(str);
                >>
              }
            ]

            SEM<<
              if (options.Count == 0)
              {
                // TODO: not sure what to do here
              }
              else if (options.Count == 1)
              {
                // no need to force ws in between, we know there must be one after it and there is only ever one symbol
                CocolExtractor.Builder.AddRule(ident, new ISymbol[] { new StringTerminal(str) }, false, true);
              }
              else
              {
                foreach(var option in options)
                {
                  // no need to force ws in between, we know there must be one after it and there is only ever one symbol
                  CocolExtractor.Builder.AddRule(ident + '>' + option, new ISymbol[] { new StringTerminal(option) }, false, true);
                }

                CocolExtractor.Builder.AddRule(
                  ident,
                  new ISymbol[] { new OneOf(false, options.Select(s => ident + '>' + s).ToArray()) },
                  false,
                  false);
              }
            >>
        |
          str<<out str>> [ AliasName ] SEM<<CocolExtractor.Builder.AddKeyword(str);>>
      ) '.'
  .

  TokenDecl =
    ( ident<<out _>> [ AliasName ] [ '=' LexExprNoRule ] | str<<out _>> [ AliasName ]) '.'
  .

  TokenClassDecl = LOCAL<<string ident = null; ISymbol[] symbols = null;>>
    ident<<out ident>> [ AliasName ]
    [
      '=' LexExpr<<ident, out symbols>>
        SEM<<CocolExtractor.Builder.AddRule(ident, symbols, false, true);>>
      [ LexDecl ] [ LexAction ]
    ] '.'
  .

  PragmaDecl =
    ident<<out _>> [ '=' LexExprNoRule [ LexDecl ] [ LexAction ] ] [ SemDecl ] [ SemAction ] '.'
  .

  LexExprNoRule =
    LexTermNoRule { '|' LexTermNoRule }
  .

  LexTermNoRule =
    LexFactNoRule { LexFactNoRule } [ 'IF' 'FOLLOWED' 'BY' '(' LexExprNoRule ')' ]
  .

  LexFactNoRule =
    ident<<out _>> | str<<out _>> | 'CHR' '(' num<<out _>> ')' | 'EOL' | '(' LexExprNoRule ')' | '[' LexExprNoRule ']' | '{' LexExprNoRule '}'
  .
  
  NonterminalDecl =
    ident<<out _>> [ AliasName ] '.'
    .

  AliasName =
    'ALIAS' ( ident<<out _>> | str<<out _>> )
  .

  LexExpr<<string name, out ISymbol[] symbols>> =
    LOCAL<<IOneOf oneOf = null;
           ISymbol[] otherSymbols = null;
           symbols = null;
           uint cnt = 1;>>

    LexTerm<<name + "|" + 0, out symbols>>
    {
      '|' LexTerm<<name + "|" + cnt, out otherSymbols>>
            SEM<<
            if (oneOf == null)
            {
              if (symbols != null)
                AddRule(name + "|" + 0, symbols);
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            else
            {
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            if (oneOf != null)
              symbols = new ISymbol[] { oneOf };

            ++cnt;

            void AddRule(string ruleName, ISymbol[] ruleSymbols)
            {
              if (oneOf == null) // to avoid null-references -> default value
                oneOf = new OneOf(false, new string[0]);

              if (ruleSymbols.Length == 0)
                oneOf = new OneOf(true, oneOf.Options);
              else
              {
                CocolExtractor.Builder.AddRule(ruleName, ruleSymbols, false);

                var options = new List<string>(oneOf.Options.Length + 1);
                options.AddRange(oneOf.Options);
                options.Add(ruleName);
                oneOf = new OneOf(oneOf.AllowNone, options.ToArray());
              }
            }
            >>
    }
  .

  LexTerm<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; ISymbol[] additionalSymbols = null; uint cnt = 1;>>
    LexFact<<name + "_0", out symbols>>
    {
      LexFact<<name + "_" + cnt, out additionalSymbols>>
      SEM<<
        ++cnt;
        var symbolList = new List<ISymbol>(symbols.Length + additionalSymbols.Length);
        symbolList.AddRange(symbols);
        symbolList.AddRange(additionalSymbols);
        symbols = symbolList.ToArray();
      >>
    }
    [ 'IF' 'FOLLOWED' 'BY' '(' LexExprNoRule ')' ]
  .

  LexFact<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; string str = null; int num = 0; ISymbol[] innerSymbols = null;>>
    // non-terminal
    ident<<out str>> SEM<<symbols = new ISymbol[] { new NonTerminal(str) };>>
    // terminal
    | str<<out str>> SEM<<symbols = new ISymbol[] { new StringTerminal(str) };>>
    // specific character
    | 'CHR' '(' num<<out num>> ')' SEM<<symbols = new ISymbol[] { new StringTerminal(num.ToString()) };>>
    // End of line
    | 'EOL' SEM<<symbols = new ISymbol[] { new AnyLineEndTerminal() };>>
    // Grouping -> simple inner rule and new NonTerminal
    //   theoretically could also check what's inside and either bubble up (if no | was used at top level)
    //   or wrap in an OneOf (if an | was used at top level)
    | '(' LexExpr<<name + "$inner", out innerSymbols>> ')'
        SEM<<
          CocolExtractor.Builder.AddRule(name + "$inner", innerSymbols, false);
          symbols = new ISymbol[] { new NonTerminal(name + "$inner") };
        >>
    // Optional -> OneOf with AllowNone=true and only option being the symbols inside
    | '[' LexExpr<<name + "$optional", out innerSymbols>> ']'
        SEM<<
          CocolExtractor.Builder.AddRule(name + "$optional", innerSymbols, false);
          symbols = new ISymbol[] { new OneOf(true, new[] { name + "$optional" }) };
        >>
    // zeroOrmore -> Transformed into new rule as following:
    //    A = { B } .
    // is transformed into
    //    A = OneOf(C)? .
    //    C = B OneOf(C)? .
    | '{' LexExpr<<name + "$zeroOrMore", out innerSymbols>> '}'
        SEM<<
          string zeroOrMoreName = name + "$zeroOrMore";

          var symbolList = new List<ISymbol>();
          symbolList.AddRange(innerSymbols);
          symbolList.Add(new OneOf(true, new[] { zeroOrMoreName }));

          CocolExtractor.Builder.AddRule(zeroOrMoreName, symbolList.ToArray(), false);
          symbols = new ISymbol[] { new OneOf(true, new[] { zeroOrMoreName }) };
        >>
 .

  RuleDef = LOCAL<<string identifier = null; ISymbol[] symbols = null;>>
    ident<<out identifier>>
    '=' [ SemDecl ] [ PreAction ] [ PostAction ]
    SynExpr<<identifier, out symbols>>
      SEM <<if (symbols != null) CocolExtractor.Builder.AddRule(identifier, symbols); >>
    '.'
  .

  SynExpr<<string name, out ISymbol[] symbols>> =
    LOCAL<<IOneOf oneOf = null;
           ISymbol[] otherSymbols = null;
           symbols = null;
           uint cnt = 1;>>

    SynTerm<<name + "|" + 0, out symbols>>
    {
      '|' SynTerm<<name + "|" + cnt, out otherSymbols>>
            SEM<<
            if (oneOf == null)
            {
              if (symbols != null)
                AddRule(name + "|" + 0, symbols);
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            else
            {
              if (otherSymbols != null)
                AddRule(name + "|" + cnt, otherSymbols);
            }
            if (oneOf != null)
              symbols = new ISymbol[] { oneOf };

            ++cnt;

            void AddRule(string ruleName, ISymbol[] ruleSymbols)
            {
              if (oneOf == null) // to avoid null-references -> default value
                oneOf = new OneOf(false, new string[0]);

              if (ruleSymbols.Length == 0)
                oneOf = new OneOf(true, oneOf.Options);
              else
              {
                CocolExtractor.Builder.AddRule(ruleName, ruleSymbols);

                var options = new List<string>(oneOf.Options.Length + 1);
                options.AddRange(oneOf.Options);
                options.Add(ruleName);
                oneOf = new OneOf(oneOf.AllowNone, options.ToArray());
              }
            }
            >>
    }
  .

  SynTerm<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; ISymbol[] additionalSymbols = null; uint cnt = 1;>>
     SynFact<<name + "_0", out symbols>>
     {
       SynFact<<name + "_" + cnt, out additionalSymbols>>
            SEM<<
            ++cnt;
            if (additionalSymbols != null)
            {
              if (symbols == null)
                symbols = additionalSymbols;
              else
              {
                var symbolList = new List<ISymbol>(symbols.Length + additionalSymbols.Length);
                symbolList.AddRange(symbols);
                symbolList.AddRange(additionalSymbols);
                symbols = symbolList.ToArray();
              }
            }
            >>
     }
 .

  SynFact<<string name, out ISymbol[] symbols>> = LOCAL<<symbols = null; string str = null; ISymbol[] innerSymbols = null;>>
    // Reference to a NonTerminal (or token class)
    ( ident<<out str>> SEM<<symbols = new ISymbol[] { new NonTerminal(str) };>>
      EPS
    // String Terminal
     | str<<out str>> SEM<<symbols = new ISymbol[] { new StringTerminal(str) };>>
    // Syn or Sem actions should be ignored
     | ( SynAction | SemAction) SEM<<symbols = null;>>
    // Grouping -> simple inner rule and new NonTerminal
    //   theoretically could also check what's inside and either bubble up (if no | was used at top level)
    //   or wrap in an OneOf (if an | was used at top level)
     | '(' SynExpr<<name + "$inner", out innerSymbols>> ')'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else {
            CocolExtractor.Builder.AddRule(name + "$inner", innerSymbols);
            symbols = new ISymbol[] { new NonTerminal(name + "$inner") };
          }>>
    // Optional -> OneOf with AllowNone=true and only option being the symbols inside
     | '[' SynExpr<<name + "$optional", out innerSymbols>> ']'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else
          {
            CocolExtractor.Builder.AddRule(name + "$optional", innerSymbols);
            symbols = new ISymbol[] { new OneOf(true, new[] { name + "$optional" }) };
          }>>
    // zeroOrmore -> Transformed into new rule as following:
    //    A = { B } .
    // is transformed into
    //    A = OneOf(C)? .
    //    C = B OneOf(C)? .
     | '{' SynExpr<<name + "$zeroOrMore", out innerSymbols>> '}'
        SEM<<
          if (innerSymbols == null)
            symbols = null;
          else
          {
            string zeroOrMoreName = name + "$zeroOrMore";

            var symbolList = new List<ISymbol>();
            symbolList.AddRange(innerSymbols);
            symbolList.Add(new OneOf(true, new[] { zeroOrMoreName }));

            CocolExtractor.Builder.AddRule(zeroOrMoreName, symbolList.ToArray());
            symbols = new ISymbol[] { new OneOf(true, new[] { zeroOrMoreName }) };
          }
        >>
     | 'EPS' SEM<<symbols = new ISymbol[0];>>
     | 'ANY' // TODO: ?
   )
 .

  LexDecl =
    'LEXLOCAL'
  .

  LexAction =
    'LEX'
  .

  SemDecl =
    'LOCAL' EPS
  .

  SynAction =
    'SYN' EPS
  .

  SemAction =
    'SEM' EPS
  .

  PreAction =
    'PRE' EPS
  .
  
  PostAction =
    'POST' EPS
  .

END Cocol2Extractor.
